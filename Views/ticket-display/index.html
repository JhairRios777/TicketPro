<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Ticket Display</title>
    <link href="/Content/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="/Content/dist/css/custom-themes.css" rel="stylesheet">
    <style>
        body{min-height:100vh;display:flex;flex-direction:column}
        .topbar{height:70px;background:var(--theme-red-primary);color:#fff;display:flex;align-items:center;justify-content:space-between;padding:0 1rem}
        .brand{font-weight:700;font-size:2rem}
        .content{display:flex;flex:1;align-items:stretch}
        /* Left: caja (columna fija) */
        .left{flex:0 0 420px;padding:3rem;display:flex;flex-direction:column;align-items:center;justify-content:flex-start}
        /* Right: espacio principal (imagen o ticket grande) */
        .right{flex:1;padding:2rem;display:flex;align-items:center;justify-content:center}
        .ticket-title{font-size:3rem;font-weight:800;color:var(--theme-red-primary);}
        .ticket-num{font-size:3rem;font-weight:800;color:var(--theme-red-primary);margin:1rem 0}
        .ticket-list{list-style:none;padding:0;margin:0;font-size:2rem;color:var(--theme-red-primary);font-weight:800}
        /* Tabla caja / tickets */
        .table-caja td, .table-caja th{border-top:0;padding:0.5rem 0}
        .table-tickets thead th{border-bottom:2px solid rgba(0,0,0,0.06)}
        .table-tickets tbody td{vertical-align:middle}
        @media (max-width:900px){
            .content{flex-direction:column}
            .left{flex:0 0 auto;width:100%}
            .right{width:100%}
        }
        /* Layout específico: left 50% / right 50% (desktop) */
        .td-left-col { flex: 0 0 50%; padding: 1rem; }
        .td-right-col { flex: 0 0 50%; padding: 1rem; display:flex; align-items:flex-start; justify-content:center }

        /* Imagen de publicidad (versión reducida respecto al tamaño principal) */
        .ad-carousel {
            width: 85%;
            max-width: 900px;
            height: calc(80vh - 80px);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ad-image {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            border-radius: 8px;
            object-fit: contain;
            box-shadow: 0 6px 18px rgba(0,0,0,0.12);
            opacity: 0;
            transition: opacity 0.6s ease-in-out;
            pointer-events: none;
        }

        .ad-image.active {
            opacity: 1;
            pointer-events: auto;
        }

        @media (max-width:900px) {
            .ad-carousel { width: 95%; height: 30vh; }
            .td-left-col { padding: 0.5rem; }
        }

        .image-placeholder {
            width:100%;
            height:calc(80vh - 80px); /* ajustar por la barra de monedas ahora visible */
            background:var(--theme-red-primary);
            border-radius:8px;
            display:flex;align-items:center;justify-content:center;color:#fff;font-weight:900;font-size:2.5rem;
        }

        /* Barra de monedas visible debajo del header */
        .currency-bar { height:60px; background:#fff; display:flex; align-items:center; justify-content:center; border-top:1px solid rgba(0,0,0,0.06); position:sticky; top:70px; z-index:1000; font-size:1.25rem; }
        .currency-bar .rates { font-weight:800; color:var(--theme-red-primary); }

        /* Textos más grandes para tabla y títulos */
        .ticket-title { font-size:2.5rem !important; }
        .ticket-num { font-size:3.5rem !important; }
        .table-tickets tbody td { font-size:1.5rem; font-weight:800; }

        @media (max-width:900px) {
            .td-left-col, .td-right-col { flex: 0 0 auto; width:100%; }
            .image-placeholder { height:30vh; }
            /* Mostrar la tabla primero en móvil */
            .td-right-col { order: -1; }
        }
    </style>
</head>
<body class="theme-red">
    <header class="topbar" style="height:70px;background:var(--theme-red-primary);color:#fff;display:flex;align-items:center;justify-content:space-between;padding:0 1rem;">
        <div class="brand"><img src="../../Content/Demo/img/LOGO_BAC.png" alt="Logo BAC" class="img-logo-selection"></div>
        <div style="display:flex;align-items:center;gap:12px">
            <div id="clock" style="font-weight:700;font-size:2.5rem">--:--</div>
            <button id="ttsToggle" class="btn btn-outline-light btn-sm" style="font-weight:700">Audio: On</button>
        </div>
    </header>

    <div class="content-container" style="display:flex;align-items:stretch;padding:1rem;margin-top:60px">
        <!-- Left: cuadro rojo donde se colocará la imagen (75%) -->
        <div class="td-left-col" style="display:flex;align-items:center;justify-content:center;">
            <div class="ad-carousel" id="adCarousel" aria-live="polite" aria-atomic="true">
                <img src="../../Content/Demo/img/publicidad_1.png" alt="Publicidad 1" class="ad-image">
                <img src="../../Content/Demo/img/publicidad_2.png" alt="Publicidad 2" class="ad-image">
                <img src="../../Content/Demo/img/publicidad_3.png" alt="Publicidad 3" class="ad-image">
                <img src="../../Content/Demo/img/publicidad_4.png" alt="Publicidad 4" class="ad-image">
            </div>
        </div>

        <!-- Right: tabla de tickets (50%) -->
        <div class="td-right-col">
            <div style="width:100%;max-width:680px">
                <table class="table table-striped table-tickets" style="background:#fff;border-radius:8px;overflow:hidden;margin-top:1rem">
                    <thead>
                        <tr>
                            <th style="font-size:40px;width:50%;text-align:center;color:var(--theme-red-primary);">Ticket</th>
                            <th style="font-size:40px;width:50%;text-align:center;color:var(--theme-red-primary);">Caja</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Barra de monedas (sticky) visible bajo el header -->
    <div class="currency-bar">
        <div class="rates" style="font-size: 2rem;">USD Compra: L. 26.29 | Venta: L. 26.42 &nbsp;&nbsp; | &nbsp;&nbsp; EUR Compra: L. 28.18 | Venta: L. 33.16</div>
    </div>

    <script>
    function updateClock(){
        const d=new Date();
        const h=d.getHours().toString().padStart(2,'0');
        const m=d.getMinutes().toString().padStart(2,'0');
        document.getElementById('clock').textContent = `${h}:${m} a.m.`;
    }
    updateClock(); setInterval(updateClock,60000);
    // local map of taken tickets (id -> { id, code, serviceDeskId, ts })
    const takenMap = {};
    // TTS: announced timestamps to avoid repeat announcements
    const announcedMap = {};

    // Admin detection: only show the audio control when URL contains ?admin=1
    const isAdmin = new URLSearchParams(location.search).get('admin') === '1';

    // TTS control stored in localStorage so admin preference persists
    let ttsEnabled = localStorage.getItem('ticket_display_tts') === '1';
    let selectedVoice = null;

    // Cache for serviceDesk names (id -> name)
    const deskNameCache = {};

    // Try to resolve a desk name by querying the display API; returns null if not found
    async function resolveDeskName(sdId){
        if(!sdId) return null;
        if(deskNameCache[sdId]) return deskNameCache[sdId];
        try{
            const body = new URLSearchParams();
            body.append('uid','consultasAPI');
            body.append('pw','API*Data123*');
            const controller = new AbortController();
            const timeout = setTimeout(()=> controller.abort(), 700); // 700ms timeout
            const res = await fetch('/APIR/index.php?method=list_display_tickets', { method: 'POST', body, signal: controller.signal });
            clearTimeout(timeout);
            if(!res.ok) return null;
            const json = await res.json();
            const taken = Array.isArray(json.taken) ? json.taken : (json.current ? (Array.isArray(json.current)?json.current:[json.current]) : []);
            for(const it of taken){
                const id = it.serviceDeskId || it.service_desk_id || it.served_by || it.user_id || null;
                if(id && String(id) === String(sdId)){
                    const name = it.serviceDeskName || it.desk_name || null;
                    if(name){ deskNameCache[sdId] = name; return name; }
                }
            }
        }catch(e){ /* ignore fetch errors or abort */ }
        return null;
    }

    // AudioContext will only be created on user gesture (admin click)
    let audioCtx = null;
    let audioInited = false;

    function initAudioContext(){
        if(audioInited) return;
        try{
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            audioInited = true;
            // resume in case it is suspended (required on some browsers)
            if(audioCtx.state === 'suspended' && typeof audioCtx.resume === 'function') audioCtx.resume().catch(()=>{});
        }catch(e){
            console.warn('Could not create AudioContext', e);
            audioInited = false;
        }
    }

    function beep(duration = 150, freq = 1000){
        if(!audioInited || !audioCtx) return Promise.resolve();
        return new Promise(resolve=>{
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = 'sine';
            o.frequency.value = freq;
            o.connect(g);
            g.connect(audioCtx.destination);
            const start = audioCtx.currentTime;
            g.gain.setValueAtTime(0.0001, start);
            g.gain.exponentialRampToValueAtTime(0.5, start + 0.01);
            o.start(start);
            const stopAt = start + duration/1000;
            g.gain.exponentialRampToValueAtTime(0.0001, stopAt + 0.02);
            setTimeout(()=>{ try{ o.stop(); }catch(e){}; resolve(); }, duration + 40);
        });
    }

    function selectSpanishVoice(){
        if(!('speechSynthesis' in window)) return null;
        const voices = window.speechSynthesis.getVoices();
        let v = voices.find(x=> x.lang && x.lang.toLowerCase().startsWith('es')) || voices.find(x=> /spanish/i.test(x.name));
        if(!v) v = voices[0] || null;
        selectedVoice = v;
        return v;
    }

    if('speechSynthesis' in window){
        window.speechSynthesis.onvoiceschanged = function(){ selectSpanishVoice(); };
        selectSpanishVoice();
    }

    function speakText(text){
        if(!ttsEnabled) return;
        if(!('speechSynthesis' in window)) return console.warn('TTS not supported');
        try{
            const utter = new SpeechSynthesisUtterance(text);
            utter.lang = 'es-ES';
            if(selectedVoice) utter.voice = selectedVoice;
            utter.rate = 0.85;
            window.speechSynthesis.cancel();
            window.speechSynthesis.speak(utter);
        }catch(e){ console.warn('TTS error', e); }
    }

    // small number->Spanish words (supports 0-99 reasonably)
    // helper to extract caja/serviceDesk id from different API shapes (top-level for announceTicket)
    function extractServiceDeskId(item){
        if(!item) return '';
        return item.serviceDeskId || item.service_desk_id || item.servicedesk_id || item.served_by || item.user_id || (item.servicedesk && (item.servicedesk.id || item.servicedesk.user_id)) || item.caja || item.box || '';
    }

    // helper to extract desk name if provided by API (top-level for announceTicket)
    function extractServiceDeskName(item){
        if(!item) return '';
        return item.serviceDeskName || item.desk_name || item.service_desk_name || (item.servicedesk && (item.servicedesk.name || item.servicedesk.desk_name)) || '';
    }

    function numberToSpanish(n){
        n = Number(n) || 0;
        const unidades = ['cero','uno','dos','tres','cuatro','cinco','seis','siete','ocho','nueve','diez','once','doce','trece','catorce','quince','dieciseis','diecisiete','dieciocho','diecinueve'];
        const decenas = ['','','veinte','treinta','cuarenta','cincuenta','sesenta','setenta','ochenta','noventa'];
        if(n < 20) return unidades[n];
        if(n < 30){
            if(n === 20) return 'veinte';
            return 'veinti' + unidades[n-20];
        }
        const d = Math.floor(n/10);
        const u = n % 10;
        return decenas[d] + (u ? ' y ' + unidades[u] : '');
    }

    async function announceTicket(item, force){
        try{
            const id = item.id || item.code || item.ticket_code || '';
            const now = Date.now();
            force = !!force;
            if(!force && announcedMap[id] && (now - announcedMap[id] < 20000)) return; // 20s debounce
            const code = item.code || item.ticket_code || item.id || '';
            const sdId = extractServiceDeskId(item) || '';
            let sdName = extractServiceDeskName(item) || '';
            // if no name provided, try to resolve quickly from server (cache) before speaking
            if(!sdName && sdId){
                try{
                    const resolved = await resolveDeskName(sdId);
                    if(resolved) sdName = resolved;
                }catch(e){ /* continue with id fallback */ }
            }
            let phrase = '';
            if(sdName){
                phrase = `Ticket ${code} en caja ${sdName}`;
            } else if(sdId && !isNaN(Number(sdId))){
                const words = numberToSpanish(Number(sdId));
                phrase = `Ticket ${code} en caja número ${words}`;
            } else {
                phrase = `Ticket ${code} en la caja`;
            }
            // play a short ding if audio initialized, then speak
            if(ttsEnabled){
                try{
                    if(audioInited){
                        await beep(150, 1000);
                    }
                }catch(e){ console.warn('beep failed', e); }
                speakText(phrase);
            }
            announcedMap[id] = now;
        }catch(e){ console.warn('announceTicket error', e); }
    }
    
    // Fetch tickets (abierto + espera) and update display every 5 seconds
    async function refreshTickets(){
        try {
            console.log('refreshTickets: start');
            const body = new URLSearchParams();
            body.append('uid','consultasAPI');
            body.append('pw','API*Data123*');

            const res = await fetch('/APIR/index.php?method=list_display_tickets', { method: 'POST', body });
            if (!res.ok) throw new Error('HTTP '+res.status);
            const json = await res.json();
            if (!json.success) throw new Error(json.message || 'API error');

            console.log('refreshTickets: got json', json);

            // Prefer explicit 'taken' list returned by API, otherwise use 'current' if present
            const taken = Array.isArray(json.taken) ? json.taken : (json.current ? (Array.isArray(json.current) ? json.current : [json.current]) : []);

            // merge API taken list with local takenMap (events) so we can show serviceDeskId when API doesn't include it
            const merged = taken.map(it=>{
                const id = it.id || it.ticket_id || it.ticket_code || it.code;
                const key = id;
                const local = takenMap[key];
                return Object.assign({}, it, local ? { serviceDeskId: local.serviceDeskId, ts: local.ts } : {});
            });

            // also include any local taken items that API hasn't yet returned (recent actions)
            Object.keys(takenMap).forEach(k=>{
                if(!merged.find(x=> (x.id && x.id == k) || (x.code && x.code == k) || (x.ticket_code && x.ticket_code == k) )){
                    merged.push(takenMap[k]);
                }
            });

            // Now ensure only one ticket per serviceDeskId: keep the most recent per desk
            const byDesk = {};
            merged.forEach(item => {
                const sd = extractServiceDeskId(item);
                const ts = item.ts || Date.now();
                if(!sd){
                    // ignore items without a serviceDeskId (not taken)
                    return;
                }
                if(!byDesk[sd] || (byDesk[sd].ts || 0) < ts){
                    byDesk[sd] = Object.assign({}, item, { serviceDeskId: sd, ts });
                }
            });
            const finalList = Object.values(byDesk).sort((a,b)=> (b.ts||0) - (a.ts||0));

            // update main ticket display (first taken) if present
            try{
                const ticketNumEl = document.querySelector('.ticket-num');
                if(ticketNumEl){
                    if (finalList.length > 0) {
                        ticketNumEl.textContent = finalList[0].code || finalList[0].ticket_code || finalList[0].id || '--';
                    } else {
                        ticketNumEl.textContent = '--';
                    }
                }
            } catch(e){ console.warn('refreshTickets: could not update main ticket element', e); }

            // populate rows with tickets that were taken (do not show queue)
            const tbody = document.querySelector('.table-tickets tbody');
            tbody.innerHTML = '';

            

            const toShow = finalList; // show one ticket per serviceDesk (most recent)
            for (let i=0;i<toShow.length;i++){
                const it = toShow[i];
                const code = it.code || it.ticket_code || it.id || it.ticket || '--';
                const sdId = extractServiceDeskId(it) || '';
                const sdName = extractServiceDeskName(it) || '';
                const cajaDisplay = sdName ? sdName : (sdId ? String(sdId) : '--');
                const tr = document.createElement('tr');
                const td1 = document.createElement('td'); td1.className='h5'; td1.style.fontWeight='800'; td1.style.color='#b71c29'; td1.style.textAlign='center'; td1.textContent = code;
                const td2 = document.createElement('td'); td2.className='h5'; td2.style.fontWeight='800'; td2.style.color='var(--theme-red-primary)'; td2.style.textAlign='center';
                td2.textContent = cajaDisplay;
                tr.appendChild(td1); tr.appendChild(td2); tbody.appendChild(tr);
            }

            // No automatic announcements here: only 'repeat' triggers audio (admin controls)

            console.log('refreshTickets: rendered', toShow.length, 'rows');

        } catch (err) {
            console.error('Error refreshing tickets:', err);
        }
    }
    refreshTickets(); setInterval(refreshTickets, 5000);
    // Listen for ticket events from other tabs (Home) and refresh immediately
    window.addEventListener('storage', function(e){
        if(!e.key) return;
        if(e.key === 'ticket_event'){
            try{
                var payload = JSON.parse(e.newValue || '{}');
                if(payload && payload.event === 'ticket_changed'){
                    // update local takenMap according to action
                            try{
                                var act = payload.action;
                                var tid = payload.id;
                                if(act === 'take'){
                                    takenMap[tid] = { id: tid, code: payload.code || payload.ticket_code || '', serviceDeskId: payload.serviceDeskId || payload.service_desk_id || payload.served_by || null, ts: payload.ts || Date.now() };
                                } else if(act === 'close'){
                                    delete takenMap[tid];
                                } else if(act === 'change_service'){
                                    // If payload contains serviceDeskId (meaning someone is attending it), set/update takenMap
                                    if(payload.serviceDeskId){
                                        takenMap[tid] = Object.assign({}, takenMap[tid] || {}, { id: tid, code: payload.code || payload.ticket_code || '', serviceDeskId: payload.serviceDeskId, ts: payload.ts || Date.now() });
                                    } else if(takenMap[tid]){
                                        // otherwise, update existing entry's serviceDeskId to newService if provided
                                        takenMap[tid].serviceDeskId = payload.newService || payload.service_id || takenMap[tid].serviceDeskId;
                                    }
                                } else if(act === 'repeat'){
                                    // force repeat announcement requested by an employee
                                    var tmp = takenMap[tid] || { id: tid, code: payload.code || payload.ticket_code || '' , serviceDeskId: payload.serviceDeskId || null };
                                    try{ announceTicket(tmp, true); }catch(e){}
                                }
                    }catch(e){ console.warn('storage payload handling error', e); }
                    // immediate refresh to reflect change
                    refreshTickets();
                }
            }catch(err){ console.error('ticket display storage parse error', err); }
        }
    });

    // BroadcastChannel (faster) listener if available
    try{
        if('BroadcastChannel' in window){
            const bc = new BroadcastChannel('ticket_events');
            bc.addEventListener('message', function(ev){
                    try{
                        const payload = ev.data;
                        if(payload && payload.event === 'ticket_changed'){
                            console.log('broadcastchannel: received ticket_changed', payload);
                            // mirror same handling as storage listener
                            try{
                                var act = payload.action;
                                var tid = payload.id;
                                if(act === 'take'){
                                    takenMap[tid] = { id: tid, code: payload.code || payload.ticket_code || '', serviceDeskId: payload.serviceDeskId || payload.service_desk_id || payload.served_by || null, ts: payload.ts || Date.now() };
                                } else if(act === 'close'){
                                    delete takenMap[tid];
                                } else if(act === 'change_service'){
                                    if(payload.serviceDeskId){
                                        takenMap[tid] = Object.assign({}, takenMap[tid] || {}, { id: tid, code: payload.code || payload.ticket_code || '', serviceDeskId: payload.serviceDeskId, ts: payload.ts || Date.now() });
                                    } else if(takenMap[tid]){
                                        takenMap[tid].serviceDeskId = payload.newService || payload.service_id || takenMap[tid].serviceDeskId;
                                    }
                                } else if(act === 'repeat'){
                                    var tmp = takenMap[tid] || { id: tid, code: payload.code || payload.ticket_code || '' , serviceDeskId: payload.serviceDeskId || null };
                                    try{ announceTicket(tmp, true); }catch(e){}
                                }
                            }catch(e){ console.warn('bc payload handling error', e); }
                            refreshTickets();
                        }
                }catch(err){ console.error('bc message parse err', err); }
            });
        }
    }catch(e){ console.warn('BroadcastChannel not available', e); }
    </script>
    <script>
    // audio/admin UI: hide toggle for public view, enable init on admin gesture
    document.addEventListener('DOMContentLoaded', function(){
        const tbtn = document.getElementById('ttsToggle');
        if(!tbtn) return;
        if(!isAdmin){
            tbtn.style.display = 'none';
            return;
        }
        // admin visible: reflect saved state
        tbtn.textContent = 'Audio: ' + (ttsEnabled ? 'On' : 'Off');
        tbtn.addEventListener('click', async function(){
            // initialize audio on first gesture
            if(!audioInited){ initAudioContext(); try{ await beep(80, 1200); }catch(e){} }
            // toggle
            ttsEnabled = !ttsEnabled;
            localStorage.setItem('ticket_display_tts', ttsEnabled ? '1' : '0');
            tbtn.textContent = 'Audio: ' + (ttsEnabled ? 'On' : 'Off');
        });
    });
    </script>
    <script>
    // Simple carousel: alterna imágenes dentro de #adCarousel cada 5 segundos
    (function(){
        const INTERVAL = 5000;
        function initAdCarousel(){
            const el = document.getElementById('adCarousel');
            if(!el) return;
            const imgs = Array.from(el.querySelectorAll('.ad-image'));
            if(!imgs.length) return;
            let idx = 0;
            imgs.forEach((img,i)=> img.classList.toggle('active', i===0));
            setInterval(()=>{
                imgs[idx].classList.remove('active');
                idx = (idx + 1) % imgs.length;
                imgs[idx].classList.add('active');
            }, INTERVAL);
        }
        if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initAdCarousel);
        else initAdCarousel();
    })();
    </script>
</body>
</html>